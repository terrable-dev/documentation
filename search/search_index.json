{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-terrable","title":"About Terrable","text":"<p>Terrable is a tool for running and debugging AWS API Gateways (defined in Terraform) locally.</p> <p>Terrable is made up of two components: a Terraform module for deploying API Gateways to AWS and a companion CLI tool that can understand and locally run an instance of your configuration for that module.</p> <p>Terrable was inspired by Serverless Framework and some of its choice plugins. However, Terraform is a first-class citizen in this world. There's not a slow, unreliable CloudFormation stack in sight!</p>"},{"location":"#why","title":"Why","text":"<p>Serverless Framework is pretty awesome, but you're stuck with CloudFormation and its various limitations by using it. Stack resource limits, slow deployments, <code>UPDATE_ROLLBACK_FAILED</code>, to name a few. There are no resource limits in Terraform, it's lightning fast when deploying changes, and the state management is excellent.</p> <p>By using the Terrable Terraform module, you're also able to use other Terraform resources alongside the Terrable module.  There are situations where you want to dynamically reference the ARN or Id of resources, such as in an IAM policy.  Well, now it's just Terraform! Simply reference it like any other Terraform resource! No need to do any hard-coding or funky CloudFormation resource lookups.</p> <p>SST is another alternative, but (currently) it requires a pretty opinionated workflow. It's incredibly cool, but if you just want to run, debug and deploy some APIs, it's a relatively complex toolchain to get into. </p> <p>Terrable also gives you the option to keep all your infrastructure as code together, assuming you want to use Terraform. There's no need to juggle YAML files or to spin up some additional JavaScript CDK projects to have a workable local-development experience.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#release-artifacts","title":"Release artifacts","text":"<p>All release artifacts are provided via the GitHub Releases, if you would like to install manually or as a workaround if your preferred installation method is not available.</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>You can install Terrable on Windows using scoop.</p> <pre><code>scoop bucket add terrable https://github.com/terrable-dev/scoop.git\nscoop install terrable\n</code></pre>"},{"location":"installation/#go","title":"Go","text":"<p>You can install Terrable using Go.</p> <pre><code>go install github.com/terrable-dev/terrable@latest\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#limitations","title":"Limitations","text":""},{"location":"limitations/#stages","title":"Stages","text":"<p>Terrable does not support stages in API Gateway, and instead substitutes a <code>default</code> stage where applicable. This has some upsides: You typically don't need to worry about deploying a stage, as terrable will do this for you. It also simplifies the usage of the module.</p> <p>If you depend on stages or just prefer to work with them then Terrable probably isn't right for you at this moment in time.</p> <p>If you want to deploy multiple versions of the Terrable API module (i.e. for production, staging, test environments) then approach it as you would any other Terraform module in your infrastructure.</p>"},{"location":"writing-handlers/","title":"Writing handlers","text":""},{"location":"writing-handlers/#minimal-handler-example","title":"Minimal handler example","text":"<p>Currently, Terrable supports JavaScript and TypeScript handlers.</p> <p>Your handler functions should export a function called <code>handler</code>, in order to be interpreted correctly by Terrable.</p> <p>The following code demonstrates a basic handler that, when invoked, will return a JSON body with the message 'Hello world!'</p> <pre><code>const handler = async (event) =&gt; {\n    return {\n        statusCode: 200,\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n            message: 'Hello world!',\n        }),\n    }\n}\n\nexport { handler };\n</code></pre> <p>This handler can then be referenced in the Terrable Terraform module as such:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\",\n        }\n    },\n  }\n}\n</code></pre>"},{"location":"cli-docs/commands/offline/","title":"Offline","text":""},{"location":"cli-docs/commands/offline/#the-terrable-offline-command","title":"The 'terrable offline' command","text":"<p>Terrable modules can be run locally via the CLI via the <code>terrable offline</code> command.</p> <p>The file name and terraform module name need to be passed to the command using the <code>--file</code> and <code>--module</code> flags. For example:</p> <pre><code>terrable offline --file \"file.tf\" --module \"module_name\"\n</code></pre> <p>You can also specify a <code>--port</code> option if you want the local server to start listening on a specific port.</p>"},{"location":"cli-docs/commands/offline/#setting-everything-up","title":"Setting everything up","text":"<p>Assuming you've installed the Terrable CLI, let's start by writing some TypeScript for our  endpoint. Create a new file, and we'll call it <code>TestHandlerSource.ts</code>.</p> <pre><code>const handler = async (event) =&gt; {\n    return {\n        statusCode: 200,\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n            message: 'Hello world!',\n        }),\n    }\n}\n\nexport { handler };\n</code></pre> <p>Let's also create a Terraform file called <code>my_api.tf</code>, and in it we'll add the terrable-api module:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\",\n        }\n    },\n  }\n}\n</code></pre> <p>Here, we can see that we've configured a handler called <code>TestHandler</code>, that uses the <code>TestHandlerSource.ts</code> file we've just written as its source. It also specifies a <code>GET</code> endpoint with the path <code>/</code>.</p> <p>Let's run our Terrable API locally. From the same directory you've created these files in:</p> <pre><code>terrable offline -f \"my_api.tf\" -m \"simple_api\"\n</code></pre> <p>You'll see an output similar to the following:</p> <pre><code>1 Endpoint(s) to prepare...\n   GET   http://localhost:8080/\nStarting server on :8080\n</code></pre> <p>Now, making a GET request to <code>http://localhost:8080/</code> should execute our handler code, and return the following JSON response:</p> <pre><code>200 OK\n{\n  \"message\": \"Hello world!\"\n}\n</code></pre>"},{"location":"cli-docs/commands/offline/#runtimes","title":"Runtimes","text":"<p>Currently, the Terrable CLI only supports Node.js runtimes. It will use whatever version of Node.js you are running on your system when executing handler code.</p>"},{"location":"cli-docs/commands/offline/#live-reloading","title":"Live reloading","text":"<p>When running locally, will watch and live-reload any handler files you change without needing to be restarted.</p>"},{"location":"cli-docs/commands/offline/#options","title":"Options","text":"<p><code>terrable offline</code> can be passed the following options.</p>"},{"location":"cli-docs/commands/offline/#file","title":"file","text":"<p>The path to the terraform file containing the Terrable API configuration module.</p> <pre><code>terrable offline --file \"terraform_file.tf\"\n</code></pre>"},{"location":"cli-docs/commands/offline/#module","title":"module","text":"<p>The name of the Terrable module in the Terraform file.</p> <pre><code>terrable offline --module \"terrable_module\"\n</code></pre>"},{"location":"cli-docs/commands/offline/#port","title":"port","text":"<p>The port to start a local server on. Defaults to 8080 or any free port if 8080 is taken.</p> <pre><code>terrable offline --port \"1234\"\n</code></pre>"},{"location":"terraform-docs/api-gateway/","title":"API gateway","text":""},{"location":"terraform-docs/api-gateway/#http-vs-rest-apis","title":"HTTP vs REST APIs","text":"<p>By default, Terrable will create HTTP API Gateways (V2).</p> <p>However, it is possible to create REST API Gateways (V1) by specifying explicitly the <code>http_api</code> or <code>rest_api</code> parameters.</p> <p>You can refer to the AWS documentation to decide which one best suits your needs.</p> <p>You can use the following syntax to define either an HTTP API or a REST API.</p> HTTP API (V2)REST API (V1) <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  http_api = {\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET   = \"/route\"\n        }\n    }\n  }\n}\n</code></pre> <p>Tip</p> <p>The <code>http_api</code> parameter is optional if you want an HTTP API but don't need any specific configuration, such as a custom domain.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  rest_api = {\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET   = \"/route\"\n        }\n    }\n  }\n}\n</code></pre>"},{"location":"terraform-docs/api-gateway/#endpoint-types","title":"Endpoint Types","text":""},{"location":"terraform-docs/api-gateway/#regional","title":"Regional","text":"<p>By default, Terrable will configure REST API Gateways (V1) with the <code>REGIONAL</code> endpoint type.</p> <p>HTTP API Gateways (V2) only support <code>REGIONAL</code> endpoint types.</p>"},{"location":"terraform-docs/api-gateway/#private","title":"Private","text":"<p>When using REST API Gateways (V1), the <code>PRIVATE</code> endpoint can be configured via the Terrable module using the following options:</p> <ul> <li><code>rest_api.endpoint_type</code> can be set to <code>PRIVATE</code></li> <li><code>rest_api.vpc_endpoint_ids</code> takes an array of VPC Endpoints that should be able allowed to invoke the API Gateway.</li> </ul> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  rest_api = {\n    endpoint_type    = \"PRIVATE\"    # Configures the API endpoints as 'PRIVATE'\n    vpc_endpoint_ids = [\"vpce-id\"]  # The VPC Endpoints to be used to generate the resource policy\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET   = \"/route\"\n        }\n    }\n  }\n}\n</code></pre> <p>This configuration will create a REST API that can only be invoked from the provided VPC Endpoints.</p> <p>This allows you to secure an API Gateway to your VPC.</p>"},{"location":"terraform-docs/api-routes/","title":"HTTP endpoints","text":""},{"location":"terraform-docs/api-routes/#declaring-endpoints","title":"Declaring endpoints","text":"<p>You can declare one or more HTTP endpoints for your handlers.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET   = \"/route\"\n          POST  = \"/route\"\n        }\n    }\n  }\n}\n</code></pre> <p>This configuration will allow you to invoke the <code>TestHandler</code> with a request to the <code>/route</code> endpoint.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET   = \"/route\"\n        }\n    }\n  }\n}\n</code></pre> <p>This configuration will allow you to invoke the <code>TestHandler</code> with both a <code>GET</code> and a <code>POST</code> request to the <code>/route</code> endpoint.</p>"},{"location":"terraform-docs/api-routes/#path-parameters","title":"Path parameters","text":"<p>Variable path parameters can be specified with the <code>{curly}</code> syntax.</p> <p>For example:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/users/{id}\" # e.g. /users/123\n        }\n    }\n  }\n}\n</code></pre> <p>This will dynamically match anything specified in place of <code>{id}</code> (eg. <code>/users/100</code>), and the value of <code>id</code> (which would be <code>100</code>) will be passed to your handler's code.</p>"},{"location":"terraform-docs/api-routes/#allowed-methods","title":"Allowed methods","text":"<p>All of the methods allowed by AWS API gateway are allowed. These include:</p> <ul> <li><code>GET</code></li> <li><code>POST</code></li> <li><code>PUT</code></li> <li><code>DELETE</code></li> <li><code>PATCH</code></li> <li><code>HEAD</code></li> <li><code>OPTIONS</code></li> <li><code>ANY</code> (matches all of the above)</li> </ul>"},{"location":"terraform-docs/custom-domains/","title":"Custom domains","text":""},{"location":"terraform-docs/custom-domains/#creating-a-custom-domain","title":"Creating a custom domain","text":"<p>If you wish to connect a custom domain to your API, you can use the <code>http_api</code> or <code>rest_api</code> inputs.</p> HTTP API (V2)REST API (V1) <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  http_api = {\n    custom_domain   = \"testdomain.test.com\" # configure this custom domain for the API\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  rest_api = {\n    custom_domain   = \"testdomain.test.com\" # configure this custom domain for the API\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>Terrable will attempt to create a custom domain (<code>testdomain.test.com</code>) and map it to your API. It will also try to create an TLS certificate.</p> <p>Note</p> <p>The base domain must exist on the AWS account being targeted. </p> <p>The Terrable module will attempt to find the base domain in the Route53 zones of the AWS account. In the example above, if <code>test.com</code> isn't a hosted zone, it will fail.</p>"},{"location":"terraform-docs/custom-domains/#use-an-existing-acm-certificate","title":"Use an existing ACM certificate","text":"<p>If you already have an ACM certificate configured, you can pass it in alongside your <code>custom_domain</code>:</p> HTTP API (V2)REST API (V1) <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  http_api = {\n    custom_domain   = \"testdomain.test.com\" # configure this custom domain for the API\n    certificate_arn = \"arn:aws:acm:us-east-1:123456789012:certificate/existing-cert-id\" # use this certificate for TLS\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  rest_api = {\n    custom_domain   = \"testdomain.test.com\" # configure this custom domain for the API\n    certificate_arn = \"arn:aws:acm:us-east-1:123456789012:certificate/existing-cert-id\" # use this certificate for TLS\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre>"},{"location":"terraform-docs/environment-variables/","title":"Environment variables","text":""},{"location":"terraform-docs/environment-variables/#global-and-individual-environment-variables","title":"Global and individual environment variables","text":"<p>You can set environment variables for your service at a global level, or at the individual handler level.</p>"},{"location":"terraform-docs/environment-variables/#global-environment-variables","title":"Global environment variables","text":"<p>You can set the <code>global_environment_variables</code> input to specify global environment variables:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  global_environment_variables = {\n    # will provide these variables to all handlers\n    GLOBAL_ONE = \"global-value\"\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>This will set the env var <code>GLOBAL_ONE=global-value</code> in all of your deployed handlers.</p> <p>Tip</p> <p>Remember, this is just Terraform! You can reference other resources and data sources in  your environment variable declarations!</p> <p>Try something like:</p> <pre><code>resource \"aws_sqs_queue\" \"sqs_queue\" {\n  name = \"my-sqs-queue\"\n}\n\nmodule \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  global_environment_variables = {\n    SQS_QUEUE_URL = aws_sqs_queue.sqs_queue.url\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>To set a global <code>SQS_QUEUE_URL</code> variable that's set to the value of the Terraformed queue's URL.</p>"},{"location":"terraform-docs/environment-variables/#handler-specific-environment-variables","title":"Handler specific environment variables","text":"<p>You can set environment variables for individual handlers by passing an <code>environment_variables</code> value into your handler declarations:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  handlers = {\n    TestHandler: {\n        environment_variables = {\n          # will provide these variables to only 'TestHandSler'\n          LOCAL_HANDLER_ONE = \"local-value\"\n        }\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>This will set a <code>LOCAL_HANDLER_ONE=local-value</code> environment variable just for <code>TestHandler</code>. Any global variable declarations will be merged with any local ones.</p>"},{"location":"terraform-docs/minimal-config/","title":"Minimal Terraform configuration","text":""},{"location":"terraform-docs/minimal-config/#minimal-config-example","title":"Minimal config example","text":"<p>A minimal Terrable Terraform configuration may look something like the following:</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>We define a module (<code>simple_api</code>) that the Terrable CLI can look for, an API name, and a handler with a HTTP endpoint (<code>TestHandler</code>).</p>"},{"location":"terraform-docs/policies/","title":"Assigning policies","text":""},{"location":"terraform-docs/policies/#global-and-individual-policies","title":"Global and individual policies","text":"<p>You can assign policies to individual handlers, and also globally at the service level.</p>"},{"location":"terraform-docs/policies/#global-policies","title":"Global policies","text":"<p>To set global policies that will be applied to every handler, the <code>global_policies</code> input can be used.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  global_policies = {\n    # apply these policies to all handlers\n    GlobalPolicy1 = \"arn:aws:iam::aws:policy/GlobalPolicy1\"\n    GlobalPolicy2 = \"arn:aws:iam::aws:policy/GlobalPolicy1\"\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>This will assign <code>arn:aws:iam::aws:policy/GlobalPolicy1</code> and <code>arn:aws:iam::aws:policy/GlobalPolicy1</code> to every handler in your configuration.</p>"},{"location":"terraform-docs/policies/#individual-handler-policies","title":"Individual handler policies","text":"<p>To specify policies for individual handlers, the <code>policies</code> attribute can be set when declaring a handler.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  handlers = {\n    TestHandler: {\n        policies = {\n          HandlerOnePolicy = \"arn:aws:iam::aws:policy/HandlerOne\" # will only be applied to 'TestHandler' \n        }\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    },\n    NoPolicyHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>This will apply the <code>arn:aws:iam::aws:policy/HandlerOne</code> policy to the <code>TestHandler</code> handler. However, the will not be applied to any other handlers, such as <code>NoPolicyHandler</code> in the above example.</p>"},{"location":"terraform-docs/vpc-assignment/","title":"VPC assignment","text":""},{"location":"terraform-docs/vpc-assignment/#assigning-security-groups-and-subnets","title":"Assigning security groups and subnets","text":"<p>To run your handlers inside a VPC, you can use the <code>vpc</code> variable.</p> <pre><code>module \"simple_api\" {\n  source = \"terrable-dev/terrable-api/aws\"\n  api_name = \"my-api\"\n  vpc = {\n    subnet_ids         = [\"subnet-12345\"]\n    security_group_ids = [\"sg-67890\", \"sg-4567\"]\n  }\n  handlers = {\n    TestHandler: {\n        source = \"./TestHandlerSource.ts\"\n        http = {\n          GET = \"/\"\n        }\n    }\n  }\n}\n</code></pre> <p>This will connect all your handlers to the specified subnets and security groups.</p> <p>Note</p> <p>Specifying a VPC configuration may significantly slow down the initial deployment of your service. With this setting, there's some additional networking configuration  that needs to be done on the AWS side.</p> <p>However, subsequent deployments should be much faster.</p>"}]}